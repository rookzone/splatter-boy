// ball.c

#include <stdlib.h>
#include <stdint.h>
#include "ball.h"
#include "graphics.h"
#include "physics.h"
#include "game_object.h"
#include "game_state.h"

GameObject* spawn_ball(uint8_t x, uint8_t y) {

    GameObject* obj = go_new_game_object(OBJ_BALL);

    if (obj == NULL)
        return NULL;
    
    // Configure components
    obj->flags |= (TRANSFORM_ACTIVE | PHYSICS_ACTIVE | RENDERER_ACTIVE);
    
    // Transform
    obj->transform.x = x;
    obj->transform.y = y;
    
    // Physics
    obj->physics.vx = 0;
    obj->physics.vy = 0;
    obj->physics.position_accumulator_x = 0;
    obj->physics.position_accumulator_y = 0;
    obj->physics.collision_enabled = 1;
    
    // Render
    GameSprite sprite = create_sprite(TILE_BALL);
    obj->renderer.sprite_index = sprite.sprite_index;
    obj->renderer.tile_index = sprite.tile_index;
    obj->renderer.visible = 1;
    
    return obj;
}

void update_ball(GameObject* obj) {

    // Quick validation
    if (!(obj->flags & PHYSICS_ACTIVE)) return;
    
    // Handle collision (use system time counter to check for frame skip)
    if (!(game.system.system_time & COLLISION_FRAME_SKIP) || obj->physics.vy > MAX_SPEED >> 1)
        check_ball_pin_collision(obj);
    
    // Update position
    update_ball_position(obj);

    // Draw at updated position
    if ((obj->flags & RENDERER_ACTIVE) == RENDERER_ACTIVE)
        DRAW_SPRITE(&obj->renderer, obj->transform.x, obj->transform.y);
    
}

// This is for testing purposes
void reset_all_balls(void) {

    for (uint8_t i = 0; i < game.objects.ball_count; i++) {

        GameObject* obj = go_get_ball(i);

        if (obj == NULL)
            continue;
        
        // Reset position
        if (i < NUM_BALLS >> 1) {
            obj->transform.x = 10 + i * 8;
            obj->transform.y = 20;
        } else {
            obj->transform.x = 10 + (i - 8) * 8;
            obj->transform.y = 30;
        }
        
        // Reset physics
        obj->physics.vx = RANDOM_HORIZONTAL_VX[i];
        obj->physics.vy = 0;
        obj->physics.position_accumulator_x = 0;
        obj->physics.position_accumulator_y = 0;
    }
}


void launch_ball_random(GameObject* ball, uint8_t from_x, uint8_t from_y, fixed_t base_power_x, fixed_t base_power_y)
{
    ball->physics.vx = 0;
    ball->physics.vy = 0;
    ball->physics.position_accumulator_x = 0;
    ball->physics.position_accumulator_y = 0;
    
    ball->transform.x = from_x;
    ball->transform.y = from_y;

    fixed_t jitter_x = (rand() & 0x7F) - 100; 
    fixed_t jitter_y = (rand() & 0x7F) - 100; 

    apply_impulse(ball, base_power_x + jitter_x, base_power_y + jitter_y);
}


void launch_ball(GameObject* ball, uint8_t from_x, uint8_t from_y, fixed_t launch_power_x, fixed_t launch_power_y)
{
    ball->physics.vx = 0;
    ball->physics.vy = 0;

    ball->physics.position_accumulator_x = 0;
    ball->physics.position_accumulator_y = 0;

    ball->transform.x = from_x;
    ball->transform.y = from_y;

    apply_impulse(ball, launch_power_x, launch_power_y);
}



GameObject* find_lowest_ball(void)
{
    GameObject* lowest_ball = game.objects.ball_pointers[0];
    // increase in y is decrease in height
    uint8_t highest_y = game.objects.ball_pointers[0]->transform.y;

    for (uint8_t i = 1; i < game.objects.ball_count; i++) {
        // Compare the current ball's y-coordinate with the maximum found so far
        if (game.objects.ball_pointers[i]->transform.y > highest_y) {
            highest_y = game.objects.ball_pointers[i]->transform.y;
            lowest_ball = game.objects.ball_pointers[i];
        }
    }

    return lowest_ball;
}

extern const fixed_t RANDOM_HORIZONTAL_VX[30] = {
    50,    // +0.5
    -50,   // -0.5
    50,    // +0.5
    50,    // +0.5
    -50,   // -0.5
    -50,   // -0.5
    50,    // +0.5
    -50,   // -0.5
    50,    // +0.5
    -50,   // -0.5
    50,    // +0.5
    -50,   // -0.5
    50,    // +0.5
    50,    // +0.5
    -50,   // -0.5
    -50,   // -0.5
    50,    // +0.5
    -50,   // -0.5
    50,    // +0.5
    -50,    // -0.5
    -50,   // -0.5
    50,    // +0.5
    -50,   // -0.5
    50,    // +0.5
    -50,    // -0.5
    -50,   // -0.5
    50,    // +0.5
    50,    // +0.5
    -50,   // -0.5
    -50   // -0.5
};

/* End of ball.c */
// ball.h

#ifndef BALL_H_
#define BALL_H_

#include "types.h"

void launch_ball_random(GameObject* ball, uint8_t from_x, uint8_t from_y, fixed_t base_power_x, fixed_t base_power_y);

GameObject* spawn_ball(uint8_t x, uint8_t y);

void update_ball(GameObject* obj);

void reset_all_balls(void);

void launch_ball(GameObject* ball, uint8_t from_x, uint8_t from_y, fixed_t launch_power_x, fixed_t launch_power_y);

GameObject* find_lowest_ball(void);

#endif // BALL_H_
// constants.h

#ifndef CONSTANTS_H_
#define CONSTANTS_H_

// Game object limits (defines fixed array size)
#define MAX_GAME_OBJECTS    40

// How many to spawn in
#define NUM_BALLS 15

// Hardware values for GB
#define NUM_HW_SPRITES  40

// Tile measurements in px
#define TILE_WIDTH          8
#define TILE_LENGTH         8
#define TILE_HALF_WIDTH     4
#define TILE_HALF_HEIGHT    4
#define TILE_HALF_LENGTH    4

// Sprite values
#define PIN_HALF_WIDTH  3
#define SPRITE_SIZE     8

// Background px and tiles for GB
#define BACKGROUND_WIDTH_TILES      20
#define BACKGROUND_HEIGHT_TILES     18
#define BACKGROUND_WIDTH_PIXELS     160
#define BACKGROUND_HEIGHT_PIXELS    144

// Tileset sizes
#define BACKGROUND_TILESET_SIZE     16
#define MENU_FONT_TILESET_SIZE      43
#define BASIC_FONT_TILESET_SIZE     43

// Offsets for font data
#define LOWER_CASE_ASCII_OFFSET     'a'
#define UPPER_CASE_ASCII_OFFSET     'A'
#define NUMBER_ASCII_OFFSET         '0'

// Friendly name that corresponds with tile position in sprite sheet(s). 
enum { TILE_BALL = 0, TILE_WALL = 1, TILE_PIN = 2 };

// === SCENES ===

#define SCENE_TITLE_SCREEN 1
#define SCENE_GAME 2
#define SCENE_GAME2 3
#define SCENE_SCORE_SCREEN 4
#define SCENE_DEMO_SCREEN 5

// Physics constants

// Check collision every other frame (0 for every frame)
#define COLLISION_FRAME_SKIP 1

// Byte that represents collidable objects
#define PIN_TILE_ID 0x02
#define WALL_TILE_ID 0x03

// Ball launcher
#define LAUNCH_FORCE_X  TO_FIXED(2)
#define LAUNCH_FORCE_Y  TO_FIXED(2)

#define GRAVITY     FIXED_TEENTH  // 256/16
#define MAX_SPEED   TO_FIXED(2) // Max speed of balls in fixed-point number space

// Ball physics
#define ROLL_FORCE              FIXED_QUARTER // Amount of force applied to ball to continue roll
#define MAX_ROLL_SPEED          TO_FIXED(2) // Max speed ball can go while rolling
#define HORIZONTAL_PIN_FORCE    FIXED_QUARTER // For bounce force on x-axis

#endif // CONSTANTS_H_
// debug.c

#include "debug.h"

/* End of debug.c */
// debug.h

#ifndef DEBUG_H_
#define DEBUG_H_

#include "types.h"

#endif // DEBUG_H_
// game_object.c

#include "game_object.h"
#include "game_state.h"
#include "graphics.h"
#include "ball.h"
#include <string.h>

// === GAME OBJECT HANDLING ===

// Spawn an object of ObjectType.
// Creates GameObject and assigns it to the pool
// Registers the object with it's specific registry function to keep track of index values
// Incriment index values ready for next object
GameObject* go_new_game_object(ObjectType type) {

    /**
     * @todo handle max objects
     */
    if (game.objects.total_count >= MAX_GAME_OBJECTS) {
        return NULL; 
    }

    uint8_t pool_index = game.objects.total_count;
    GameObject* obj = &game.objects.pool[pool_index];

    // Zero out object values in case any junk values exist.
    memset(obj, 0, sizeof(GameObject));
    
    // Set up object values
    obj->id = pool_index;
    obj->flags = OBJECT_ACTIVE;
    obj->type = type;
    
    // Register objects in their type specific registries
    if (type == OBJ_BALL && game.objects.ball_count < MAX_GAME_OBJECTS) {
        game.objects.ball_pointers[game.objects.ball_count] =  &game.objects.pool[pool_index];
        game.objects.ball_count++;
    }

    // Register in type-specific registry
    if (type == OBJ_GENERIC && game.objects.generic_count < MAX_GAME_OBJECTS) {
        game.objects.generic_pointers[game.objects.generic_count] =  &game.objects.pool[pool_index];
        game.objects.generic_count++;
    }

    // Change to switch case when more objects are built
    
    game.objects.total_count++;
    return obj;
}

// Update all registered GameObjects

void go_update_all_balls(void) {
    // Iterate through ball registry
    for (uint8_t i = 0; i < game.objects.ball_count; i++) {
        update_ball(game.objects.ball_pointers[i]);
    }
}

// void go_update_all_walls
// void go_update_all_spinners


GameObject* go_get_ball(uint8_t index) {

    if (index < game.objects.ball_count) {
        return game.objects.ball_pointers[index];
    }
    return NULL;
}

/* End of game_object.c */
// game_object.h

#ifndef GAME_OBJECT_H_
#define GAME_OBJECT_H_

#include "types.h"

GameObject* go_new_game_object(ObjectType type);

// Update registered GameObjects
void go_update_all_balls(void);

// Return ball GameObject defined at position index using ball registry
GameObject* go_get_ball(uint8_t index);

#endif // GAME_OBJECT_H_
// game_data.c

#include "game_state.h"
#include "graphics.h"
#include <string.h>
#include <stdio.h>
#include "platform.h"

GameState game;

/**
 * @todo Allow a mask to be passed for fine control over
 * any parts of the state that should persist
 */
void clear_game_state(GameState* game)
{
    platform_display_off();

    hide_all_sprites();

    // Wipe GameObjects and Graphics.
    memset(&game->objects, 0, sizeof(ObjectManager));
    memset(&game->graphics, 0, sizeof(Graphics));

}

void update_game_state(void)
{
    // Refresh system values
    game.system.previous_keys = game.system.keys;
    game.system.keys = platform_get_input();
    game.system.system_time = platform_get_sys_time();

    game.system.sys_time_since_state_load++;
}

/* End of game_data.c */
// game_data.h

#ifndef GAME_STATE_H_
#define GAME_STATE_H_

#include "types.h"

// === GAME STATE SUB SYSTEMS ===

typedef struct {

    uint8_t current_scene;
    uint8_t keys;
    uint8_t previous_keys;
    uint8_t paused;
    uint16_t system_time;
    uint16_t sys_time_since_state_load;


} System;

typedef struct {
    
    // === GRAPHICS DATA ===
    unsigned char *active_background_tilemap;
    unsigned char *active_background_tileset;
    unsigned char *active_sprite_sheet;
    unsigned char *active_font;

    // === MEMORY TRACKING ===
    // fonts
    uint16_t basic_font_vram_start_location;
    // Sprites
    uint16_t next_sprite_slot;
    uint8_t sprite_count;
    // Background
    uint16_t next_background_tile_slot;
    uint16_t active_background_tileset_size;
    uint16_t background_vram_start_location;

} Graphics;

typedef struct {
    // Object pool (all game objects live here)
    GameObject pool[MAX_GAME_OBJECTS];
    uint8_t total_count;
    
    // Game object pointer registries
    GameObject* ball_pointers[MAX_GAME_OBJECTS];
    uint8_t ball_count;

    GameObject* generic_pointers[MAX_GAME_OBJECTS];
    uint8_t generic_count;

} ObjectManager;

// === GAME STATE ===

typedef struct {

    System system;
    Graphics graphics;
    ObjectManager objects;

} GameState;


extern GameState game;

// Clean up the state ready for a new setup
void clear_game_state(GameState* game);

void update_game_state(void);


#endif // GAME_STATE_H_
// graphics.c

#include "types.h"
#include "graphics.h"
#include "game_state.h"
#include <stdio.h>

// Create sprite with a tracked VRAM number, assign tile, create and return GameSprite object
GameSprite create_sprite(uint8_t tile_index)
{
    GameSprite new_sprite;
    new_sprite.sprite_index = game.graphics.next_sprite_slot;
    new_sprite.tile_index = tile_index;
    platform_set_sprite_tile(game.graphics.next_sprite_slot, tile_index);
    game.graphics.next_sprite_slot++;

    return new_sprite;
}

// Plot a point at position in fixed number space
void plot_point_fixed(fixed_t x, fixed_t y)
{
    platform_plot_point(FROM_FIXED(x), FROM_FIXED(y));
}

void set_game_background(unsigned char *background, unsigned char *tiles, uint16_t tileset_size)
{
    game.graphics.active_background_tilemap = background;
    game.graphics.active_background_tileset = tiles;
    game.graphics.active_background_tileset_size = tileset_size;
    game.graphics.background_vram_start_location = game.graphics.next_background_tile_slot;

    platform_set_bkg_data(
        game.graphics.background_vram_start_location,
        game.graphics.active_background_tileset_size,
        game.graphics.active_background_tileset
    );

    platform_set_bkg_tiles(0, 0, BACKGROUND_WIDTH_TILES, BACKGROUND_HEIGHT_TILES, game.graphics.active_background_tilemap);
    
    game.graphics.next_background_tile_slot += game.graphics.active_background_tileset_size;
}

void reload_active_background(void)
{
    platform_set_bkg_tiles(0, 0, BACKGROUND_WIDTH_TILES, BACKGROUND_HEIGHT_TILES, game.graphics.active_background_tilemap);
}

void load_background_tiles(unsigned char *tiles, uint16_t count)
{
    // Load tiles into vram at next available vram slot, size count, array tiles
    platform_set_bkg_data(game.graphics.next_background_tile_slot, count, tiles);

    // Increment next available vram slot
    game.graphics.next_background_tile_slot += count;
}

unsigned char* get_game_background_tilemap(void)
{
    return game.graphics.active_background_tilemap;
}

void set_active_basic_font(unsigned char *font, uint16_t size)
{
    if(!game.graphics.active_font){

        game.graphics.basic_font_vram_start_location = game.graphics.next_background_tile_slot;
        load_background_tiles(font, size);
        game.graphics.active_font = font;
    }
}

void print_text(char* str, uint8_t cursor_start_x, uint8_t cursor_start_y)
{
    uint16_t index = 0;

    uint16_t cursor_x = cursor_start_x;
    uint16_t cursor_y = cursor_start_y;

    while(str[index]!='\0'){

        // Auto new line if cursor reached edge of screen
        if (cursor_x == BACKGROUND_WIDTH_TILES-2){

            // draw a dash if previous index was NOT a space (as this is continuation of a word)
            if ( index > 0 && str[index] != ' ' && str[index-1] != ' ' ){

                uint8_t tile_offset = get_font_tile_index('-');

                uint16_t letter_vram_location = 
                    game.graphics.basic_font_vram_start_location + tile_offset;
                
                uint8_t *cursor_address = platform_get_bkg_xy_addr(cursor_x, cursor_y);
                platform_set_vram_byte(cursor_address, letter_vram_location);

            }

            cursor_y++;
            cursor_x = cursor_start_x;

            continue;
        }

        // New line
        if ((uint8_t)str[index] == '\n'){

            cursor_y++;
            cursor_x = cursor_start_x;
            index++;
            continue;

        }

        // We need to get the tile index based on the tileset rather than ascii
        // Returns the equivalent location in the tileset of ascii value
        uint8_t tile_offset = get_font_tile_index(str[index]);

        uint16_t letter_vram_location = 
            game.graphics.basic_font_vram_start_location + tile_offset;
        
        uint8_t *cursor_address = platform_get_bkg_xy_addr(cursor_x, cursor_y);
        platform_set_vram_byte(cursor_address, letter_vram_location);

        cursor_x++;

        index++;
    }
}


void text_clear_screen(void)
{
    for (uint8_t i = 1; i <= DEVICE_SCREEN_HEIGHT; i++){
        print_text("                    ",1,i);
    }
}

uint8_t get_font_tile_index(char ascii_location) {

    // Handle Uppercase (A-Z)
    if (ascii_location >= 'A' && ascii_location <= 'Z') {
        return (ascii_location - 'A'); // Returns 0-25
    }

    // Handle Lowercase (a-z)
    if (ascii_location >= 'a' && ascii_location <= 'z') {
        return (ascii_location - 'a'); // Returns 0-25
    }
    
    // Handle Numbers (0-9)
    if (ascii_location >= '0' && ascii_location <= '9') {
        return (ascii_location - '0') + 26; // Returns 26-35
    }

    switch (ascii_location){

        case ' ':
            return 36;
        break;

        case '-':
            return 37;
        break;

        case ',':
            return 38;
        break;

        case '.':
            return 39;
        break;

        case '!':
            return 40;
        break;

        case '?':
            return 41;
        break;

        case '>':
            return 42;
        break;

    }
    
    return 36; // Default to ' '
}


void set_sprite_sheet(unsigned char *sprite_sheet)
{
    game.graphics.active_sprite_sheet = sprite_sheet;
    platform_set_sprite_data(0, 16, game.graphics.active_sprite_sheet);
}

void hide_all_sprites(void)
{ 
// Iterate through all 40 hardware sprites
    for (uint8_t i = 0; i < NUM_HW_SPRITES; i++) {
        // This removes any sprites from the screen, they can be reallocated.
        platform_move_sprite(i, 0, 0); 
    }
}

// ===  ===

/* End of graphics.c */
/**
 * @file graphics.h
 * @brief Handles drawing of background, window or sprite tiles on screen.
 * * @details Contains useful macros for handling tile grids and pixels.
 * Functions to load tiles, backgrounds, and sprites. The GameSprite struct is used.
 * This contains the tile_index and sprite_index, these are indices that reference the ID in memory.
 * Memory is managed in here, so the logic can just ask for something to be drawn without worrying about IDs and memory.
 * The GameSprite object reference that is returned can be used to call graphics functions.
 * Passing around structs is slow, so try and keep that stuff out of any update loops.
 * * @defgroup Graphics
 */

#ifndef GRAPHICS_H_
#define GRAPHICS_H_

#include "types.h"
#include "platform.h"

// Convert Pixel coordinate to Grid coordinate (Divide by 8)
#define PIXEL_TO_GRID(x) ((x) >> 3)

// Convert Grid coordinate to Pixel coordinate (Multiply by 8)
#define GRID_TO_PIXEL(x) ((x) << 3)

// Get tilemap Array Index from Col/Row (Row * Width + Col)
#define GET_TILE_INDEX(col, row) ((((uint16_t)(row) << 4) + ((uint16_t)(row) << 2)) + (col))

// === SPRITE HANDLING ===

// Allocates a sprite at sprite_index with a tile at tile_index
GameSprite create_sprite(uint8_t tile_index);

// === BACKGROUNDS ===

// Loads background tiles and map into memory
void set_game_background(unsigned char *background, unsigned char *tiles, uint16_t tileset_size);

void reload_active_background(void);

unsigned char* get_game_background_tilemap(void);

void load_background_tiles(unsigned char *tiles, uint16_t count);

// Load in a sprite sheet
void set_sprite_sheet(unsigned char *sprite_sheet);

void hide_all_sprites(void);

// === DRAWING ===

// Draw sprite at obj->sprite_index
#define DRAW_SPRITE(obj_ptr, x, y) \
    platform_move_sprite((obj_ptr)->sprite_index, x + 8, y + 16)

// Plot a point at position in pixel space (int)
void plot_point_fixed(fixed_t x, fixed_t y);

// === FONT AND TEXT ===

// Returns the tile index of the font as it does not map to ascii
uint8_t get_font_tile_index(char c);

void print_text(char* str, uint8_t cursor_start_x, uint8_t cursor_start_y);

void text_clear_screen(void);

void set_active_basic_font(unsigned char *font, uint16_t size);

#endif // GRAPHICS_H_
// input.c

#include "game_state.h"
#include "input.h"


//* End of input.c */
#ifndef INPUT_H_
#define INPUT_H_

#include "types.h"

static inline uint8_t get_key_pressed_down(uint8_t key)
{
    return(game.system.keys & key && !(game.system.previous_keys & key));
}


#endif // INPUT_H_
// main.c

#include "scene_manager.h"
#include "debug.h"
#include "game_state.h"
#include "input.h"
#include "graphics.h"
#include "platform.h"
#include "tiles/menuFont.h"

// Forward declarations
void pause_game(void);

void main(void) 
{
    // Load first "game" scene
    set_scene(SCENE_TITLE_SCREEN);

    while (1) {

        // Update state, required every frame
        update_game_state();

        // Pause on start
        if (get_key_pressed_down(J_START)){
            pause_game(); // Update text showing if paused
        }

        update_scene(); // Update game scene

        platform_vsync(); // Await frame end

    }
}

void pause_game(void)
{

    if(game.system.current_scene == SCENE_TITLE_SCREEN)
        return; // Do not pause on title screen

    game.system.paused = !game.system.paused;

    // Load font if required.
    if (!game.graphics.active_font)
        set_active_basic_font(menuFont, BASIC_FONT_TILESET_SIZE);

    if (game.system.paused == 1){
        platform_hide_sprites();
        print_text("GAME PAUSED...",3 ,8);
    } else if (game.system.paused == 0) {
        // Clear text
        reload_active_background();
        platform_show_sprites();
    }
}

/* End of main.c */
// physics.c

#include "graphics.h"
#include "physics.h"
#include "game_state.h"

void update_ball_position(GameObject* ball)
{
    ball->physics.vy += GRAVITY;

    if (ball->physics.vy > MAX_SPEED)
        ball->physics.vy = MAX_SPEED;
    
    // Add the velocity (rate of change) into the positional accumulator
    ball->physics.position_accumulator_x += ball->physics.vx;
    ball->physics.position_accumulator_y += ball->physics.vy;

    // Shifts whole number part of accumulator to right-hand byte and applies to screen position
    ball->transform.x += (int8_t)(ball->physics.position_accumulator_x >> FIXED_SHIFT);
    ball->transform.y += (int8_t)(ball->physics.position_accumulator_y >> FIXED_SHIFT);
    
    // Now chop off left-hand byte as that whole number has already been added to the screen position
    // This leaves us with just the fractional part, ready for the next frame!
    ball->physics.position_accumulator_x &= 0xFF;
    ball->physics.position_accumulator_y &= 0xFF;

}

void apply_impulse(GameObject* obj, fixed_t impulse_magnitude_x, fixed_t impulse_magnitude_y)
{
    obj->physics.vx += impulse_magnitude_x;
    obj->physics.vy += impulse_magnitude_y;
}

void check_ball_pin_collision(GameObject* ball)
{
    
    // FILTER: Only handle collision if ball is moving downward
    if (ball->physics.vy <= 0)
        return;

    // Get ball's bottom-middle point
    uint8_t ball_bottom_x = ball->transform.x + TILE_HALF_WIDTH;
    uint8_t ball_bottom_y = ball->transform.y  + TILE_WIDTH;

    // Find which 8x8 tile the ball's bottom is in
    uint8_t col = PIXEL_TO_GRID(ball_bottom_x);
    uint8_t row = PIXEL_TO_GRID(ball_bottom_y);

    // FILTER: Outside screen, do not collide
    if (col >= BACKGROUND_WIDTH_TILES || row >= BACKGROUND_HEIGHT_TILES)
        return;

    // Grab the tiles index value
    uint16_t tilemap_index = GET_TILE_INDEX(col, row);

    // FILTER: Check the tile in the map at that index, if it's a pin tile we need to collide
    if (game.graphics.active_background_tilemap[tilemap_index] != PIN_TILE_ID && 
    game.graphics.active_background_tilemap[tilemap_index] != WALL_TILE_ID)
        return;
            
    // Get coords of pin tile
    uint8_t pin_tile_x = GRID_TO_PIXEL(col);
    uint8_t pin_tile_y = GRID_TO_PIXEL(row);

    // Calculate horizontal distances to determine if ball will hit pin
    uint8_t pin_center_x = pin_tile_x + TILE_HALF_WIDTH;
    int8_t distance_x = ball_bottom_x - pin_center_x;
    
    // FILTER: check if ball is within horizontal collision bounds
    if (distance_x < -(PIN_HALF_WIDTH) || distance_x > (PIN_HALF_WIDTH))
        return;

    // Calculate vertical distance so collision only happens from above
    uint8_t pin_center_y = pin_tile_y + PIN_HALF_WIDTH;
    int8_t distance_y = ball_bottom_y - pin_center_y;
    
    // FILTER: check if ball is within verticle collision bounds (ignore collision from below)
    if (distance_y < 0 || distance_y > TILE_HALF_WIDTH)
        return;

    // Zero fractional velocity
    ball->physics.position_accumulator_y = 0;

    if (ball->physics.vy > FIXED_QUARTER) { 
        // === BOUNCE ===
        
        // Vertical bounce (50% energy)
        ball->physics.vy = -(ball->physics.vy >> 1);
        
        // If ball moving right and hits left side (distance_x < 0), bounce left
        // If ball moving left and hits right side (distance_x > 0), bounce right
        if ((ball->physics.vx > 0 && distance_x < 0) || (ball->physics.vx < 0 && distance_x > 0)) {
            // Hit the "wrong" side - reverse direction with damping
            ball->physics.vx = -(ball->physics.vx >> 1);
        } else {
            // Hit the "correct" side - keep direction but add deflection force
            ball->physics.vx = (ball->physics.vx >> 1);
            
            // Add a nudge based on offset from center
            if (distance_x > 0) {
                ball->physics.vx += FIXED_EIGHTH;  // nudge right
            } else if (distance_x < 0) {
                ball->physics.vx -= FIXED_EIGHTH;  // nudge left
            } else {
                // Dead center hit - give it a small nudge to break symmetry
                ball->physics.vx += (ball->transform.y & 1) ? FIXED_EIGHTH : -FIXED_EIGHTH;
            }
        }
        
    } else { 

        // === ROLL ===
        
        ball->physics.vy = 0;
        
        // Shift distance_x to scale it down
        ball->physics.vx += distance_x;
        
        // Clamp horizontal speed
        if (ball->physics.vx > MAX_ROLL_SPEED) ball->physics.vx = MAX_ROLL_SPEED;
        else if (ball->physics.vx < -MAX_ROLL_SPEED) ball->physics.vx = -MAX_ROLL_SPEED;

    }
}

/* End of physics.c */
/**
 * @file physics.h
 * @brief Contains physics functionality to the Game Objects.
 * * @details This contains functions for object movement and interactions.
 * The physics is not true to life but is instead optimised for speed.
 * As long as it looks good and it's cheap then that's fine.
 * We have constants that define certain forces like gravity and roll speed.
 * All physics interactions take place in "fixed-number space".
 * This means that the fixed number decimals are used for higher precision.
 * The update_position functions will convert the numbers back to integer and set x,y.
 * * @defgroup Physics
 */
#ifndef PHYSICS_H_
#define PHYSICS_H_

#include "types.h"

// === FORCE ===

// Apply instant impulse force to ball
void apply_impulse(GameObject* obj, fixed_t impulse_magnitude_x, fixed_t impulse_magnitude_y);

// === BALL PHYSICS ===

void update_ball_position(GameObject* obj);
void check_ball_pin_collision(GameObject* obj);

// === LOOKUP TABLES ===

// Random horizontal velocities for ball resets
extern const fixed_t RANDOM_HORIZONTAL_VX[30];

#endif // PHYSICS_H_
// platform.h

#ifndef PLATFORM_H_
#define PLATFORM_H_

#include <stdint.h>

// Platform identifiers
#define PLATFORM_GB     1
#define PLATFORM_GBA    2

#define TARGET_PLATFORM PLATFORM_GB

// Include the appropriate platform implementation
#if TARGET_PLATFORM == PLATFORM_GB
    #include "platform/gb/platform_gb.h"
#elif PLATFORM == PLATFORM_GBA
    #include "platform/gba/platform_gba.h"
#else
    // Default to Game Boy if nothing specified
    #define PLATFORM_GB
    #include "platform/gb/platform_gb.h"
#endif

#endif // PLATFORM_H_
// scene_manager.c

#include "scene_manager.h"
#include "game_state.h"
#include "platform.h"

// Scene headers
#include "scenes/scene_title_screen.h"
#include "scenes/scene_game.h"
#include "scenes/scene_game2.h"


void set_scene(uint8_t new_scene)
{
    if (game.system.current_scene != new_scene) {

        game.system.paused = 0; // Make sure game isn't paused
        game.system.current_scene = new_scene;

        init_scene();
    }
}


void init_scene(void)
{
    switch (game.system.current_scene) 
    {
        case SCENE_GAME:
            clear_game_state(&game); // Wipe game state for new load
            init_game_scene(); // Init game screen code in scenes/
            break;
        case SCENE_GAME2:
            clear_game_state(&game); // Wipe game state for new load
            init_game2_scene(); // Init game screen code in scenes/
            break;
        case SCENE_TITLE_SCREEN:
            clear_game_state(&game);
            init_title_scene();
            break;

        default:
            // Handle unknown scene - back to title?zx
            break;
    }
}

void update_scene(void)
{
    if (game.system.paused == 1) // Do not update scene if game paused
        return;

    switch (game.system.current_scene) 
    {
        case SCENE_GAME:
            update_game_scene();
            break;
        case SCENE_GAME2:
            update_game2_scene();
            break;
        case SCENE_TITLE_SCREEN:
            update_title_scene();
            break;

        default:
            // Handle unknown scene
            break;
    }
}

void cleanup_scene(void)
{
    uint8_t current_scene = game.system.current_scene;

    switch (current_scene) 
    {
        case SCENE_GAME:
            cleanup_game_scene();
            break;
        case SCENE_GAME2:
            cleanup_game2_scene();
            break;
        case SCENE_TITLE_SCREEN:
            cleanup_title_scene();
            break;

        default:
            // Handle unknown scene
            break;
    }
}

/* End of scene_manager.c */
//scene_manager.h


#ifndef SCENE_MANAGER_H_
#define SCENE_MANAGER_H_

#include "types.h"

void set_scene(uint8_t scene);

void init_scene(void);

void update_scene(void);

void pause_scene(void);

void cleanup_scene(void);

#endif // SCENE_MANAGER_H_
// types.h

#ifndef types_H_
#define types_H_

#include "constants.h"
#include <stdint.h>

typedef struct GameSprite GameSprite;

// ***** FIXED NUMBERS *****
// These are a way to represent decimal numbers
// We use a 16bit integer and shift the 8 bit integer to left byte
// right byte represents a decimal in 1/256ths

typedef int16_t fixed_t;

// Fractional fixed-point increment (1/256 resolution).
// Represents only magnitude.
// Intended to be added to or subtracted from a signed fixed_t
// accumulator (positional_accumulator_x,y) for sub-pixel motion.
typedef uint8_t fraction_t;


#define FIXED_SHIFT   8           // number of fractional bits
#define FIXED_ONE     (1 << FIXED_SHIFT)   // 1.0 in fixed (256)
#define FIXED_HALF    (1 << (FIXED_SHIFT - 1)) // 0.5 (128)     << 7
#define FIXED_QUARTER (1 << (FIXED_SHIFT - 2)) // 0.25 (64)     << 6
#define FIXED_EIGHTH  (1 << (FIXED_SHIFT - 3)) // 0.125 (32)    << 5
#define FIXED_TEENTH  (1 << (FIXED_SHIFT - 4)) // (16)          << 4
#define FIXED_TENBAG  (1 << (FIXED_SHIFT - 5)) // (8)           << 3


// === CONVERSION HELPERS ===
#define TO_FIXED(x)   ((fixed_t)((x) << FIXED_SHIFT))       // int -> fixed
#define FROM_FIXED(x) ((x) >> FIXED_SHIFT)                // fixed -> int
#define FIXED_ADD(a,b) ((a) + (b))
#define FIXED_SUB(a,b) ((a) - (b))

// === SLOW MATHS ===
#define FIXED_MUL(a,b) (((a) * (b)) >> FIXED_SHIFT)
#define FIXED_DIV(a,b) (((a) << FIXED_SHIFT) / (b))



// === GAME OBJECT ===

// === COMPONENT FLAGS ===
#define OBJECT_ACTIVE    0x01  // Object is alive
#define TRANSFORM_ACTIVE 0x02  // Has position
#define PHYSICS_ACTIVE   0x04  // Has velocity/physics
#define RENDERER_ACTIVE    0x08  // Has sprite/should render

// === GAME OBJECT ===

// Create definitions for the different object types
typedef enum {
    OBJ_BALL,
    OBJ_PIN,
    OBJ_SLANTED_WALL,
    OBJ_GENERIC,
    OBJ_SPINNER
} ObjectType;

// ** Components **
typedef struct{

    fixed_t vx, vy; // Velocity
    fixed_t position_accumulator_x, position_accumulator_y; // Velocity fractional accumulater (sub-pixel)
    uint8_t collision_enabled; // 1 = enable collision, 0 = ignore collision

} PhysicsComponent;

typedef struct{

    uint8_t sprite_index; // the index this sprite was initialised at
    uint8_t tile_index;
    uint8_t visible;

} RenderComponent;

typedef struct {

    uint8_t x, y; // Position in pixels
    
} TransformComponent;

typedef struct {

    uint8_t id;
    uint8_t flags;
    ObjectType type;

    // Components

    TransformComponent transform;
    PhysicsComponent physics;
    RenderComponent renderer;

} GameObject;

// === Graphics ===

struct GameSprite {
    uint8_t sprite_index;
    uint8_t tile_index;
};

#endif // types_H_
//AUTOGENERATED FILE FROM png2asset

const unsigned char arod_gb_tiles[3200] = {
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xfb,0xfc,0xfe,0xfc,
	0xff,0xff,0xff,0xff,
	0xfc,0xf8,0xf1,0xfe,
	0x14,0xf9,0xdf,0xbe,
	0xd4,0x03,0x54,0x28,
	0xe0,0xc2,0xaf,0x10,
	0xed,0x7e,0x02,0x3c,
	0xea,0xc0,0x55,0x03,
	0xdf,0x07,0x25,0x1b,
	0x01,0x00,0x1d,0x02,
	0x3f,0x0b,0xff,0x3f,
	0xff,0x7f,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xc3,0x81,0x07,0x00,
	0x03,0x01,0x36,0xc0,
	0xdd,0x73,0x7b,0xfc,
	0xfd,0xff,0xff,0xff,
	0xcf,0xaf,0xe8,0x13,
	0x43,0x09,0x3e,0x00,
	0xbe,0x21,0xfe,0x8f,
	0x13,0xef,0x9f,0x7f,
	0xff,0xfd,0xfd,0xfd,
	0xff,0xfd,0xf6,0x78,
	0xb7,0x08,0x77,0x80,
	0xdf,0xe0,0xf9,0xf8,
	0xd6,0xe0,0x2b,0xf0,
	0xfa,0xe0,0xdb,0x20,
	0x56,0xe1,0x3b,0xc0,
	0xf1,0x9a,0x73,0x98,
	0xb3,0x3f,0x57,0x3f,
	0xf7,0x9f,0x86,0xff,
	0xbd,0xc7,0xd4,0x2f,
	0xd9,0x6d,0x7f,0xc9,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xfa,0xff,0xfd,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xab,0xff,
	0xd5,0xff,0x54,0xff,
	0xd6,0xff,0x28,0xff,
	0xfd,0xfe,0xfc,0xff,
	0xc6,0xf0,0xf7,0xf8,
	0x7e,0xff,0xf8,0xff,
	0xbd,0x7f,0x3e,0xc3,
	0xe4,0x00,0xf7,0xb0,
	0x07,0x00,0x81,0x00,
	0xb7,0x43,0xbd,0xc3,
	0x7f,0x83,0xff,0x07,
	0xe7,0x1f,0x7f,0x1f,
	0xbf,0x7f,0x7f,0xff,
	0xff,0xff,0xfe,0xff,
	0xfd,0xf8,0xf0,0xe0,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xfe,0xff,
	0xfe,0xfd,0xdc,0xa0,
	0x00,0x00,0x00,0x00,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0x6f,0x1f,0x0b,0x00,
	0x00,0x00,0x00,0x00,
	0xbf,0xff,0x5f,0xf7,
	0xfe,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0x5f,0x3f,0x1e,0x01,
	0xfc,0xff,0xfe,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xfd,0x03,0x0b,0xf7,
	0xa7,0xff,0xf7,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xcf,0xf3,0xc1,0xef,
	0x8f,0xf8,0xfb,0x80,
	0x9f,0xc0,0xbc,0xc3,
	0xbb,0xc4,0xff,0x80,
	0xef,0xff,0x12,0xfd,
	0xd0,0x2f,0xff,0x00,
	0xf7,0x08,0xff,0x00,
	0x7f,0x80,0xfe,0x00,
	0xd6,0xff,0xf5,0xff,
	0xea,0xff,0xfd,0xff,
	0xea,0xff,0xf7,0xff,
	0xfa,0xff,0xea,0xff,
	0xa6,0xff,0xaa,0xff,
	0xa5,0xff,0xaa,0xff,
	0xa9,0xff,0x55,0xff,
	0xaa,0xff,0xab,0xff,
	0x43,0xff,0xbf,0xfe,
	0x7f,0xfc,0xf7,0xf8,
	0x4f,0xf1,0x13,0xef,
	0x5b,0xbf,0xbf,0x7f,
	0xef,0x1f,0xff,0x3f,
	0xff,0x7e,0xfe,0xfc,
	0xfc,0xf8,0xf8,0xf0,
	0xf8,0xe0,0xe0,0xe0,
	0xc0,0x80,0x80,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0xd4,0x3b,0x4f,0x01,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0xff,0xff,0xff,0xff,
	0xaf,0x7f,0x11,0x0e,
	0x17,0x0f,0x17,0x0f,
	0x0f,0x1f,0x1f,0x0f,
	0xa0,0x80,0xa1,0xc0,
	0xfb,0xe0,0xfa,0xf4,
	0xf9,0x3f,0xbc,0xdf,
	0xea,0xff,0xfd,0xef,
	0xf8,0x00,0x72,0x80,
	0x5c,0x00,0x28,0x00,
	0xf3,0x00,0x79,0xc6,
	0x3b,0xe7,0x8c,0xf3,
	0xef,0xff,0xdd,0xff,
	0xeb,0xff,0xf7,0xff,
	0xfa,0xff,0xea,0xff,
	0xf5,0xff,0xf4,0xff,
	0xfb,0xff,0xda,0xff,
	0xf5,0xff,0x7a,0xff,
	0xaa,0xff,0xa8,0xff,
	0x12,0xff,0xa0,0xff,
	0x55,0xff,0x55,0xff,
	0x2a,0xff,0x95,0xff,
	0x4b,0xff,0x26,0xff,
	0x9f,0xff,0x6a,0xff,
	0x7f,0xff,0xf7,0xff,
	0xff,0xff,0xf7,0xff,
	0xff,0xff,0xf7,0xff,
	0x7f,0xf6,0xe6,0xfe,
	0xe0,0xc0,0xc0,0xc0,
	0x80,0x80,0x00,0x80,
	0x80,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x0b,0x3f,0x1f,0x1f,
	0x1d,0x1f,0x0f,0x1f,
	0x1e,0x1f,0x0f,0x1f,
	0x0f,0x1f,0x1f,0x1f,
	0xf9,0xf7,0xf7,0xfb,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xe2,0xfd,0xfe,0xf1,
	0xf5,0xfa,0xfb,0xfc,
	0xfd,0xfe,0xff,0xfe,
	0xff,0xff,0xff,0xff,
	0xfa,0xff,0xfa,0xff,
	0xfc,0xff,0xfb,0xff,
	0xfe,0xff,0xfb,0xff,
	0xfd,0xff,0xfe,0xff,
	0x02,0xff,0x91,0xff,
	0x44,0xff,0x57,0xff,
	0xaa,0xff,0xb7,0xff,
	0xdd,0xff,0xb6,0xff,
	0x5d,0xff,0x6b,0xff,
	0xb6,0xff,0x55,0xff,
	0xd5,0xff,0x56,0xff,
	0x55,0xff,0xab,0xff,
	0xbe,0xfc,0xb0,0xfc,
	0xe8,0xfc,0x78,0xf8,
	0xb8,0xf8,0xd9,0xf7,
	0xaf,0xf7,0xe7,0xf7,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x0c,0x1e,
	0x7d,0x3e,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0xf8,0x00,0x21,0xf0,
	0xf0,0xe0,0xf0,0xe0,
	0x10,0x00,0x2b,0x00,
	0x22,0x01,0x13,0x0f,
	0x77,0x0f,0xdf,0x3f,
	0xff,0xff,0x7f,0xff,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x87,0x40,
	0xf3,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0x02,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x40,0x80,0x80,0xe0,
	0xf0,0xf8,0xfe,0xfc,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0x00,
	0x02,0x01,0x02,0x01,
	0x01,0x00,0x01,0x00,
	0xff,0x0f,0x07,0x7f,
	0xff,0x3f,0xbf,0x7f,
	0xdd,0x7f,0x2f,0xff,
	0x7f,0xff,0x7f,0xff,
	0xdf,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xef,0xff,0xf7,0xff,
	0xf3,0xff,0xf3,0xff,
	0xfb,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xe8,0xff,
	0xea,0xff,0xa0,0xff,
	0xff,0xff,0xff,0xff,
	0xfe,0xff,0xed,0xff,
	0x55,0xff,0xa2,0xff,
	0x28,0xff,0x81,0xff,
	0xd5,0xff,0xba,0xff,
	0xc4,0xff,0x28,0xff,
	0x40,0xff,0x00,0xff,
	0x00,0xff,0x02,0xfd,
	0x54,0xff,0xa2,0xff,
	0x08,0xff,0x00,0xff,
	0x00,0xff,0x00,0xff,
	0x05,0xfa,0xb5,0x4a,
	0x85,0xff,0x10,0xff,
	0x02,0xff,0x00,0xff,
	0x00,0xff,0x00,0xff,
	0x50,0xaf,0x44,0xbb,
	0x47,0xf4,0x9d,0xe0,
	0x97,0xe8,0x0b,0xe3,
	0x5f,0xe3,0x2b,0xc7,
	0x1f,0xe7,0x17,0xe3,
	0x77,0x0f,0xd2,0x21,
	0xe0,0x00,0xff,0xfe,
	0xe9,0xd1,0xf0,0xf0,
	0xd0,0xe0,0xe0,0x00,
	0xe0,0xe0,0xe0,0xc0,
	0xc0,0x00,0x01,0x00,
	0x01,0x00,0x00,0x00,
	0x00,0x00,0x02,0x00,
	0xff,0x7f,0xbf,0x7f,
	0x98,0x7f,0xd0,0x6f,
	0x5d,0xe3,0x1b,0xe7,
	0x9f,0x67,0x0b,0x70,
	0xb3,0xc0,0x70,0x80,
	0x8a,0x00,0xa0,0xc0,
	0xfc,0xf8,0xff,0xfe,
	0xff,0x7f,0x4d,0x1f,
	0x7e,0xfc,0x7f,0x1e,
	0x77,0x0f,0xf7,0x0f,
	0x33,0x4f,0x4b,0x37,
	0xf9,0x9e,0xfc,0xff,
	0x00,0x00,0x00,0x00,
	0x80,0x00,0x00,0x80,
	0x80,0xc0,0xe0,0xc0,
	0x20,0xc0,0x30,0xc0,
	0x3f,0xff,0x7f,0x7f,
	0x7f,0x3f,0x1f,0x3f,
	0x2f,0x1f,0x1f,0x0f,
	0x0f,0x07,0x0f,0x07,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xfe,0xff,
	0xfc,0xff,0xfd,0xff,
	0xf8,0xff,0xfc,0xff,
	0xc4,0xff,0x10,0xff,
	0x00,0xff,0x01,0xfe,
	0x04,0xfb,0x0a,0xf5,
	0x01,0xfe,0x0a,0xf5,
	0x00,0xff,0x00,0xff,
	0x02,0xfd,0x0a,0xf5,
	0xa2,0x5d,0x4a,0xb5,
	0x09,0xf6,0x22,0xdd,
	0x14,0xeb,0x6a,0x95,
	0xad,0x52,0xa7,0x58,
	0xb5,0x4a,0xaf,0x50,
	0x5a,0xa5,0xaf,0x50,
	0xa5,0x5a,0xaa,0x55,
	0x55,0xaa,0xdb,0x24,
	0x6d,0x92,0x5b,0xa4,
	0xef,0x10,0xff,0x00,
	0x50,0xaf,0xd6,0x29,
	0xaa,0x55,0x74,0x8b,
	0xae,0x51,0x75,0x8a,
	0xfb,0x04,0xff,0x00,
	0x03,0xe0,0x00,0xe0,
	0x80,0x60,0xc0,0x00,
	0x00,0xc0,0x00,0x00,
	0x00,0x80,0x80,0x00,
	0x3f,0x40,0x7e,0x00,
	0x7c,0x00,0x2c,0x00,
	0x30,0x00,0x08,0x00,
	0x18,0x00,0x18,0x00,
	0x41,0x3f,0x11,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0xf9,0xfe,0xd3,0x6c,
	0x0f,0x00,0x07,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0xf0,0x00,0xf0,0x00,
	0xf0,0x00,0x80,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x07,0x0f,0x17,0x0f,
	0x07,0x0f,0x17,0x0f,
	0x1f,0x0f,0x0f,0x1f,
	0x3f,0x1f,0xff,0x1f,
	0xff,0xff,0xff,0xff,
	0xbf,0xff,0xdf,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xf8,0xff,0xf4,0xff,
	0xf9,0xff,0xf4,0xff,
	0xfa,0xff,0xfa,0xff,
	0xfa,0xff,0xfd,0xff,
	0x00,0xff,0x0a,0xf5,
	0x04,0xfb,0x11,0xee,
	0x08,0xf7,0x15,0xea,
	0x0a,0xf5,0x11,0xee,
	0x09,0xf6,0x85,0x7a,
	0x54,0xab,0x0a,0xf5,
	0xb5,0x4a,0x55,0xaa,
	0xae,0x51,0x5a,0xa5,
	0x57,0xa8,0x7b,0x84,
	0x9e,0x61,0xeb,0x14,
	0x7f,0x80,0xbf,0x40,
	0xff,0x00,0xbe,0x40,
	0xdb,0x24,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xba,0x00,0xb5,0x00,
	0xff,0x00,0xfe,0x01,
	0xff,0x00,0xdf,0x00,
	0x6f,0x00,0xaf,0x00,
	0xab,0x00,0x57,0x00,
	0x00,0x00,0x80,0x00,
	0x80,0x00,0x80,0x00,
	0x80,0x00,0x00,0x00,
	0x80,0x00,0x80,0x00,
	0x00,0x00,0x0b,0x18,
	0x1c,0x1f,0x1f,0x1f,
	0x1a,0x0f,0x03,0x0c,
	0x07,0x06,0x00,0x07,
	0x08,0x30,0xf8,0x7e,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0x63,0xff,
	0x0d,0x02,0x7b,0x07,
	0x08,0x00,0x00,0x00,
	0x80,0x00,0x80,0xc0,
	0xc8,0xe0,0xe8,0xf0,
	0xb0,0x70,0xf0,0xe0,
	0x00,0x00,0x01,0x00,
	0x03,0x00,0x03,0x00,
	0x06,0x01,0x05,0x03,
	0xd1,0x0f,0xe3,0x1f,
	0xff,0x3f,0xff,0x7f,
	0x7f,0xff,0x7f,0xff,
	0x3f,0xff,0x3f,0xff,
	0x7f,0xff,0xff,0x7f,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xfe,0xfd,0xfe,
	0xfb,0xfc,0xfa,0xfd,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xa3,0xc3,
	0x01,0x01,0xd1,0x20,
	0x7c,0xfc,0xff,0xfe,
	0x0d,0xf2,0x05,0xfa,
	0x85,0xfa,0x01,0xfe,
	0x42,0xfd,0x02,0xfd,
	0xc1,0xfe,0x82,0xfd,
	0x57,0xa8,0x7d,0x82,
	0x55,0xaa,0x5b,0xa4,
	0xde,0x21,0xb5,0x4a,
	0x6f,0x90,0xdf,0x20,
	0xfd,0x00,0x7e,0x80,
	0xbe,0x40,0xff,0x00,
	0xbf,0x40,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xd5,0x00,0xab,0x00,
	0xbf,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0x5f,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0x00,0x80,0x80,0x00,
	0x80,0x00,0x80,0x00,
	0x80,0x00,0x80,0x00,
	0x80,0x00,0x00,0x00,
	0x0d,0x0f,0x07,0x1f,
	0x1a,0x3f,0x3c,0x3f,
	0x3e,0x7d,0x70,0x78,
	0x2c,0xf0,0xfe,0x00,
	0xa2,0x5c,0x59,0xa6,
	0x3b,0xc6,0x0c,0xff,
	0xdd,0xbe,0x2c,0x1f,
	0x3a,0x07,0x9f,0x60,
	0xa0,0x40,0x00,0x00,
	0x00,0x00,0x40,0x00,
	0xc0,0x00,0x60,0x80,
	0xa8,0x50,0xbc,0x40,
	0x01,0x00,0x00,0x00,
	0x00,0x00,0x03,0x00,
	0x07,0x00,0x05,0x00,
	0x07,0x00,0x05,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xfe,0x01,0x5f,0x00,
	0xbf,0x7f,0x3e,0xff,
	0x03,0xfc,0x3c,0xc0,
	0x38,0x40,0xdc,0x20,
	0xf8,0x00,0xf0,0x00,
	0xf9,0xff,0xf0,0xff,
	0xe6,0x7c,0x3f,0x0e,
	0x1e,0x1f,0x07,0x0a,
	0x0b,0x00,0x1b,0x00,
	0xfe,0xff,0x3f,0x8f,
	0x0e,0x0f,0x0d,0x0e,
	0x0a,0x0e,0x84,0x0c,
	0x81,0x0c,0xc2,0x0d,
	0xfe,0xff,0xff,0xff,
	0xfd,0xff,0xfd,0xff,
	0xfb,0xff,0xf5,0xff,
	0xed,0xff,0xaa,0xff,
	0x82,0xfd,0x41,0xfe,
	0x40,0xff,0x52,0xfd,
	0x40,0xff,0x00,0xff,
	0x40,0xff,0x90,0xff,
	0xff,0x00,0x7f,0x80,
	0xbf,0x40,0xaf,0x50,
	0xab,0x54,0xad,0x52,
	0x2b,0xd4,0x52,0xad,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0x7f,0x80,0xdf,0x20,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xfe,0x00,
	0x03,0x00,0x03,0x00,
	0x02,0x01,0x06,0x01,
	0x05,0x03,0x03,0x07,
	0x0f,0x0e,0x1f,0x0c,
	0x7f,0x8e,0x1f,0xff,
	0x79,0xf8,0xc0,0x80,
	0x80,0x00,0xc0,0x00,
	0xf6,0x03,0xfe,0x03,
	0xb3,0xfc,0xff,0xfe,
	0xff,0x1f,0x05,0x03,
	0x05,0x00,0x00,0x00,
	0x71,0x80,0xa7,0xd8,
	0x3e,0xc0,0x3f,0xe0,
	0xcf,0xf0,0xf7,0xf8,
	0x5e,0x39,0x69,0x1e,
	0xee,0x1f,0xcf,0x3f,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0xc0,0x00,
	0xe0,0x00,0xc0,0x00,
	0x61,0x80,0x60,0x81,
	0x02,0x00,0x03,0x00,
	0x07,0x00,0x0d,0x00,
	0x1f,0x00,0x17,0x00,
	0x9f,0x00,0xff,0x00,
	0xdf,0x00,0xff,0x00,
	0xff,0x00,0xbf,0x00,
	0xbf,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xf0,0x00,0x30,0xc0,
	0xd0,0x20,0xd1,0x20,
	0xb0,0x40,0xd0,0x20,
	0x72,0x80,0xf7,0x00,
	0x1b,0x00,0x1d,0x63,
	0xdf,0xe3,0xd6,0xe3,
	0x80,0x40,0x06,0x01,
	0x00,0x01,0xc0,0x00,
	0xcf,0x0b,0x03,0xdf,
	0x57,0x97,0xb7,0x27,
	0x1f,0x6f,0xcf,0xdf,
	0x9f,0x1f,0x1f,0x3f,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xf4,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xfa,0xff,0xc0,0xff,
	0x01,0xfe,0x5f,0xa0,
	0xfd,0xff,0xf4,0xff,
	0xd2,0xff,0x48,0xff,
	0x80,0xff,0x01,0xfe,
	0x56,0xa9,0xff,0x00,
	0x51,0xff,0xa4,0xff,
	0x00,0xff,0x00,0xff,
	0x00,0xff,0x50,0xaf,
	0xe8,0x17,0xf6,0x09,
	0x10,0xff,0x48,0xff,
	0x24,0xff,0x8b,0xff,
	0x21,0xff,0x0d,0xff,
	0x02,0xff,0x05,0xff,
	0x09,0xf6,0x02,0xfd,
	0x00,0xff,0x00,0xff,
	0x40,0xff,0x50,0xff,
	0xa8,0xff,0x54,0xff,
	0x7f,0x80,0x2f,0xd0,
	0xad,0x52,0x57,0xa8,
	0x2d,0xd2,0x56,0xa9,
	0x2b,0xd4,0x04,0xfb,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0x7a,0x85,0xf6,0x09,
	0xba,0x45,0xca,0x35,
	0xfe,0x00,0xff,0x00,
	0xfe,0x00,0xfe,0x00,
	0xbe,0x40,0xfe,0x00,
	0xab,0x54,0xaf,0x50,
	0x1e,0x0c,0x7f,0x10,
	0x75,0x30,0x77,0x60,
	0x6b,0xe0,0x4f,0xc0,
	0x02,0x00,0x1e,0x91,
	0xec,0x13,0xf8,0x07,
	0xef,0x1f,0xdf,0x2f,
	0xef,0x1f,0xf7,0x0f,
	0x23,0x00,0xa0,0x00,
	0x60,0x9f,0xfd,0x5e,
	0xfb,0xfc,0xff,0xf8,
	0xfd,0xf2,0xf5,0xfa,
	0xff,0x00,0x17,0x00,
	0xe7,0x1f,0xf7,0x0f,
	0xfb,0x07,0xfd,0x03,
	0xfe,0x01,0xff,0x00,
	0xff,0x00,0x7f,0x80,
	0xf8,0x00,0xff,0x00,
	0x7d,0x82,0x6a,0x9f,
	0x3f,0xff,0xfe,0x7f,
	0xff,0x7f,0xff,0x7f,
	0xfc,0x01,0x9f,0x60,
	0xdf,0x20,0x9f,0xf0,
	0xe2,0xdd,0x79,0xde,
	0xab,0xdc,0xee,0xfd,
	0xfa,0x05,0xfb,0x04,
	0xfd,0x06,0xfd,0x02,
	0x37,0xce,0xe5,0x0c,
	0xa7,0x1c,0xac,0xdf,
	0xab,0x40,0xbf,0x40,
	0xbd,0x46,0x77,0x8e,
	0x97,0xee,0xef,0xfd,
	0x52,0xfc,0xfe,0xf0,
	0xa0,0x00,0xe1,0x00,
	0x83,0x01,0x5b,0x07,
	0xaf,0x5f,0xff,0xff,
	0x3f,0x7f,0xff,0x7f,
	0xbf,0x7f,0x7f,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xc0,0xff,
	0x90,0xff,0x07,0xf8,
	0x1f,0xe0,0x7c,0x80,
	0x78,0x80,0xe0,0x00,
	0x01,0xfe,0x0f,0xf0,
	0x7c,0x80,0xe0,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0xea,0x00,0x80,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0xb7,0x00,0x01,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0xfd,0x02,0x7f,0x00,
	0x8f,0x00,0xe3,0x00,
	0x03,0x00,0x11,0x00,
	0x00,0x00,0x00,0x00,
	0x80,0x7f,0xa1,0x5f,
	0xe0,0x1f,0xf0,0x0f,
	0xfc,0x03,0x7e,0x01,
	0x5d,0x02,0x3f,0x00,
	0xaa,0xff,0x50,0xff,
	0x6a,0xff,0x10,0xff,
	0x24,0xff,0x88,0x7f,
	0x00,0xff,0x42,0xbf,
	0x23,0xdc,0x09,0xf6,
	0x10,0xef,0x02,0xfd,
	0x08,0xf7,0x00,0xff,
	0x00,0xff,0x00,0xff,
	0x68,0x97,0x04,0xfb,
	0xa0,0x5f,0x00,0xff,
	0x00,0xff,0x00,0xff,
	0x00,0xff,0x00,0xff,
	0xaf,0x50,0x3b,0xc4,
	0x8e,0x70,0x3f,0xc0,
	0x56,0xa8,0x1f,0xe0,
	0x57,0xa8,0x2f,0xd0,
	0xce,0x80,0x00,0x00,
	0x80,0x80,0x80,0x00,
	0x00,0x00,0x20,0x00,
	0x40,0x00,0x80,0x00,
	0x1b,0x00,0x02,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0xff,0x00,0xfc,0x00,
	0xe8,0x00,0x5f,0x00,
	0xa1,0x00,0x21,0x00,
	0x03,0x01,0x35,0x0f,
	0xff,0xff,0xff,0xfe,
	0x7f,0xbf,0x7f,0xbf,
	0xff,0x3f,0xff,0xdf,
	0xff,0xff,0x7f,0xff,
	0xef,0xfc,0xee,0xff,
	0xf3,0xff,0xfd,0xff,
	0xff,0xef,0xff,0xef,
	0xff,0xef,0xb7,0xff,
	0xba,0x7f,0x7b,0xbf,
	0x5b,0xff,0xdf,0xff,
	0x7f,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xfe,0xf0,0xf7,0xe0,
	0xd4,0xe0,0xb0,0xc0,
	0xe8,0xc0,0x60,0xc0,
	0x60,0x80,0x40,0x80,
	0xff,0x7f,0xff,0x7f,
	0xff,0x7f,0xff,0x7f,
	0xff,0x7f,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xc0,0x00,0x80,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x0f,0x00,0x1f,0x00,
	0x07,0x00,0x07,0x00,
	0x01,0x00,0x03,0x00,
	0x00,0x00,0x00,0x00,
	0x80,0x7f,0xf0,0x0f,
	0xe8,0x17,0xf0,0x0f,
	0xfc,0x03,0xfc,0x03,
	0xfe,0x01,0x7e,0x01,
	0x00,0xff,0x40,0xff,
	0x04,0xff,0x12,0xff,
	0x0a,0xff,0x25,0xff,
	0x15,0xff,0x16,0xff,
	0x04,0xff,0x20,0xff,
	0x90,0xff,0x40,0xff,
	0x90,0xff,0x40,0xff,
	0x50,0xff,0x92,0xff,
	0x3f,0xc0,0x2f,0xd0,
	0x3f,0xc0,0x9f,0xe0,
	0xff,0x80,0xdf,0xe0,
	0xff,0xc0,0xdf,0xe0,
	0x80,0x00,0x90,0x00,
	0x9c,0x0c,0xcb,0x04,
	0xc1,0x01,0xc1,0x01,
	0x80,0x00,0x80,0x00,
	0x08,0x00,0x08,0x00,
	0x3d,0x00,0x79,0x07,
	0x5f,0xfe,0xff,0xff,
	0xff,0xff,0xff,0x7f,
	0x00,0x00,0x00,0x00,
	0xd2,0x00,0xf1,0x00,
	0x37,0xb0,0xff,0xaf,
	0xff,0xff,0xff,0xff,
	0x1f,0x01,0x1f,0x11,
	0x3f,0xbf,0x3f,0x3f,
	0xff,0x7f,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xbf,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xfe,0xff,0xfc,0xff,
	0xff,0xff,0xfe,0xff,
	0xfb,0xfc,0xf7,0xf8,
	0xdf,0xe0,0x8f,0xf0,
	0xbf,0xc0,0x57,0xa8,
	0x00,0x80,0x00,0x00,
	0x51,0x00,0x01,0x00,
	0x81,0x00,0xc1,0x01,
	0xc2,0x01,0x81,0x03,
	0x3e,0x01,0x3e,0x01,
	0x3f,0x00,0x1f,0x00,
	0x1e,0x01,0x1f,0x00,
	0x0e,0x01,0x0f,0x00,
	0x0f,0xff,0x17,0xff,
	0x1e,0xff,0x0f,0xff,
	0x1f,0xff,0x1f,0xff,
	0x1f,0xff,0x3f,0xff,
	0x68,0xff,0xd4,0xff,
	0xfb,0xff,0xfe,0xff,
	0xfc,0xff,0xfe,0xff,
	0xfe,0xff,0xfe,0xff,
	0x3f,0xc0,0x3f,0xc0,
	0x3f,0xc0,0x3e,0xc0,
	0x7c,0x80,0x3c,0xc0,
	0x7c,0x80,0x78,0x80,
	0x80,0x00,0x00,0x00,
	0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x3f,0x3f,0x7f,0x1f,
	0xef,0x1f,0xff,0x07,
	0x3f,0x01,0x37,0x00,
	0x44,0x00,0x03,0x00,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0x7f,0xff,
	0xff,0x00,0xb0,0x00,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xfa,0xff,
	0x8b,0x7c,0x7b,0x04,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0x0b,0xf6,
	0xcb,0x35,0xdf,0x20,
	0xf0,0xff,0xb2,0xfd,
	0x0b,0xf4,0xdb,0xf5,
	0x6e,0x91,0xff,0x00,
	0x7f,0x80,0xff,0x00,
	0xbe,0x40,0x3f,0xc0,
	0xff,0x00,0xff,0x00,
	0xfe,0x00,0xfe,0x00,
	0xff,0x00,0xff,0x00,
	0x33,0x03,0xcb,0x03,
	0xe7,0x03,0x97,0x03,
	0xd7,0x07,0x87,0x0f,
	0xdf,0x0f,0xff,0x1f,
	0x0e,0x01,0x0e,0x01,
	0x0c,0x03,0x00,0x00,
	0x00,0x00,0x0c,0x00,
	0x0c,0x38,0x70,0xf8,
	0x1f,0xff,0x7f,0xff,
	0x20,0xf1,0x00,0x00,
	0x00,0x00,0x03,0x03,
	0x0f,0x0f,0x3f,0x1f,
	0xfe,0xff,0xfb,0xfc,
	0xc1,0x01,0x02,0x00,
	0x00,0x00,0x02,0x0c,
	0xfc,0xfe,0xf8,0xf8,
	0x70,0x80,0xef,0x7f,
	0xff,0xff,0x50,0x20,
	0x0f,0x1f,0x7f,0x3f,
	0x7f,0xff,0x7f,0xff,
	0x00,0x00,0xe0,0xc0,
	0xb0,0xc0,0x00,0x30,
	0xf0,0xf0,0xf8,0xf0,
	0xf8,0xf0,0xf0,0xf8,
	0x1f,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0x0f,0x00,0x0f,0x00,
	0x17,0x00,0x17,0x00,
	0x17,0x00,0x1b,0x00,
	0x0f,0x00,0x3f,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xfe,0x00,
	0xfe,0x00,0xdb,0x00,
	0xfd,0x02,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0x0f,0x00,
	0xff,0x00,0xff,0x00,
	0xff,0x00,0xff,0x01,
	0xfb,0x07,0xff,0x0f,
	0xef,0x1f,0xff,0x3f,
	0xff,0x3f,0xff,0x7f,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xc3,0xff,0x00,0xf8,
	0xe1,0xfe,0xfb,0xff,
	0xff,0xff,0xff,0xff,
	0xe0,0xf8,0x7c,0xff,
	0x7e,0xff,0x7f,0xff,
	0x7f,0xff,0x7f,0xff,
	0x7f,0xff,0xff,0xff,
	0x01,0x00,0x06,0x00,
	0x03,0x00,0x01,0x00,
	0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0xff,0xff,
	0xff,0xff,0x7f,0xff,
	0xff,0x7f,0xff,0x3f
	};


const unsigned char arod_gb_map[360] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1b,0x1b,0x1c,0x1d,0x1e,0x1f,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x21,0x22,0x23,0x24,0x1b,0x1b,0x1b,0x1b,0x1b,0x25,0x26,0x27,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,
	0x00,0x00,0x00,0x00,0x00,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x40,0x41,0x00,0x00,
	0x00,0x00,0x00,0x00,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x1b,0x1b,0x49,0x4a,0x4b,0x4c,0x4d,0x00,0x4e,
	0x00,0x00,0x00,0x00,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x1b,0x1b,0x59,0x5a,0x5b,0x5c,
	0x00,0x00,0x00,0x00,0x12,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,0x1b,0x66,0x67,0x68,0x69,0x6a,
	0x00,0x00,0x00,0x00,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,
	0x00,0x7b,0x7c,0x7d,0x7e,0x7f,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,
	0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x1b,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0x00,
	0xa0,0x1b,0x1b,0x1b,0x1b,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0x00,0xaa,0xab,0xac,0x00,0x00,
	0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0xad,0xae,0xaf,0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0x00,0x00,
	0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0x1b,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc4,
	0x1b,0x1b,0x59,0x2f,0x04,0x13,0x00,0x8d,0x26,0xab,0xc5,0x30,0xc6,0x92,0x9a,0x2e,0x8d,0x00,0x00,0x00,
	0x75,0x04,0x8d,0x00,0x00,0x00,0x00,0x00,0x00,0xa5,0xc7,0x00,0xc5,0x8d,0x00,0x00,0x00,0x00,0x00,0x00,
	0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x27,0x87,0xc7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
//AUTOGENERATED FILE FROM png2asset
#ifndef METASPRITE_arod_gb_H
#define METASPRITE_arod_gb_H

#define arod_gb_TILE_ORIGIN 0
#define arod_gb_TILE_W 8
#define arod_gb_TILE_H 8
#define arod_gb_WIDTH 160
#define arod_gb_HEIGHT 144
#define arod_gb_TILE_COUNT 200
#define arod_gb_PALETTE_COUNT 1
#define arod_gb_COLORS_PER_PALETTE 4
#define arod_gb_TOTAL_COLORS 4
#define arod_gb_MAP_ATTRIBUTES 0
extern const unsigned char arod_gb_map[360];
#define arod_gb_map_attributes arod_gb_map

extern const unsigned char arod_gb_tiles[3600];

#endif

/*

 GAME1MAP.C

 Map Source File.

 Info:
   Section       : 
   Bank          : 0
   Map size      : 20 x 18
   Tile set      : game_pachinko_tiles.gbr
   Plane count   : 1 plane (8 bits)
   Plane order   : Tiles are continues
   Tile offset   : 0
   Split data    : No

 This file was generated by GBMB v1.8

*/

#define game1MapWidth 20
#define game1MapHeight 18
#define game1MapBank 0

unsigned char game1Map[] =
{
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x02,0x0F,0x02,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x02,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x02,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x02,0x0F,0x0F,0x02,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x02,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x02,0x0F,0x0F,0x0F,0x02,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x02,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x02,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x09,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x02,
  0x0F,0x0F,0x0F,0x0F,0x02,0x0F,0x02,0x0F,0x0F,0x0F,
  0x08,0x09,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x03,
  0x08,0x0A,0x0F,0x0F,0x02,0x0F,0x0F,0x02,0x0F,0x02,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x03,0x05,
  0x0A,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x03,0x05,0x04,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x02,0x0F,0x0F,0x0F,0x03,0x05,0x04,0x04,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x02,0x0F,0x0F,0x0F,0x03,0x05,0x04,0x04,0x04,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x02,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x03,0x05,0x04,0x04,0x04,0x04,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x03,0x05,0x04,0x04,0x04,0x04,0x04,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x03,0x05,0x04,0x04,0x04,0x04,0x04,0x04
};

unsigned char game1Tiles[] =
{
  0x00,0x00,0x3C,0x3C,0x76,0x78,0x7A,0x7E,
  0x7E,0x7E,0x7E,0x7E,0x3C,0x3C,0x00,0x00,
  0xFF,0xFF,0x00,0xFF,0x00,0xFF,0xFF,0x00,
  0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x10,
  0x00,0x3C,0x10,0x18,0x00,0x00,0x00,0x00,
  0x00,0x01,0x00,0x03,0x00,0x07,0x00,0x0F,
  0x00,0x1F,0x00,0x3F,0x00,0x7F,0x00,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0x01,0xFF,0x03,0xFF,0x07,0xFF,0x0F,0xFF,
  0x1F,0xFF,0x3F,0xFF,0x7F,0xFF,0xFF,0xFF,
  0x00,0x80,0x00,0xC0,0x00,0xE0,0x00,0xF0,
  0x00,0xF8,0x00,0xFC,0x00,0xFE,0x00,0xFF,
  0x80,0xFF,0xC0,0xFF,0xE0,0xFF,0xF0,0xFF,
  0xF8,0xFF,0xFC,0xFF,0xFE,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0x00,0x80,0x00,0x40,0x80,0xA0,0xC0,0xD0,
  0xA0,0xE8,0x90,0xF4,0x88,0xFA,0xFC,0xFD,
  0xFC,0xFD,0xF8,0xFA,0xF0,0xF4,0xE0,0xE8,
  0xC0,0xD0,0x80,0xA0,0x00,0x40,0x00,0x80,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

/* End of GAME1MAP.C */

/*

 GAME1MAP.H

 Map Include File.

 Info:
   Section       : 
   Bank          : 0
   Map size      : 20 x 18
   Tile set      : game_pachinko_tiles.gbr
   Plane count   : 1 plane (8 bits)
   Plane order   : Tiles are continues
   Tile offset   : 0
   Split data    : No

 This file was generated by GBMB v1.8

*/

#define game1MapWidth   20
#define game1MapHeight  18
#define game1MapBank    0
#define game1TilesBank  0

extern unsigned char game1Map[];
extern unsigned char game1Tiles[];

/* End of GAME1MAP.H */

/*

 GAME2MAP.C

 Map Source File.

 Info:
   Section       : 
   Bank          : 0
   Map size      : 20 x 18
   Tile set      : game_pachinko_tiles.gbr
   Plane count   : 1 plane (8 bits)
   Plane order   : Tiles are continues
   Tile offset   : 0
   Split data    : No

 This file was generated by GBMB v1.8

*/

#define pachinko1Width 20
#define pachinko1Height 18
#define pachinko1Bank 0

unsigned char game2Map[] =
{
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x02,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x02,0x0F,0x0F,0x0F,0x0F,
  0x02,0x0F,0x0F,0x0F,0x0F,0x02,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x02,0x0F,0x0F,0x0F,0x0F,0x0F,0x02,0x0F,
  0x0F,0x0F,0x02,0x0F,0x02,0x02,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x02,0x02,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x02,0x0F,
  0x0F,0x0F,0x0F,0x02,0x02,0x02,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x02,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x02,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x02,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x02,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x02,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x02,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x02,0x0F,0x0F,0x0F,0x0F,0x02,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x02,0x0F,
  0x02,0x02,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x02,0x0F,0x02,0x0F,0x0F,0x0F,0x0F,
  0x02,0x0F,0x0F,0x0F,0x0F,0x02,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x01,0x01,0x0F,0x0F,0x0F,0x01,0x01,0x01,0x01,0x0F,
  0x0F,0x0F,0x01,0x01,0x01,0x0F,0x0F,0x0F,0x01,0x01
};

/* End of GAME2MAP.C */

/*

 GAME2MAP.H

 Map Include File.

 Info:
   Section       : 
   Bank          : 0
   Map size      : 20 x 18
   Tile set      : game_pachinko_tiles.gbr
   Plane count   : 1 plane (8 bits)
   Plane order   : Tiles are continues
   Tile offset   : 0
   Split data    : No

 This file was generated by GBMB v1.8

*/

#define pachinko1Width 20
#define pachinko1Height 18
#define pachinko1Bank 0

extern unsigned char game2Map[];

/* End of GAME2MAP.H */

// platform/gb/platform_gb.h

#ifndef PLATFORM_GB_H_
#define PLATFORM_GB_H_

#include <gb/gb.h>
#include <gb/drawing.h>
#include <gbdk/console.h>
#include <stdint.h>

/**
 * PLATFORM WRAPPERS (GBDK SPECIFIC)
 * These functions wrap GBDK calls to decouple game logic from the SDK.
 */

// === System & Hardware ===

static inline uint16_t platform_get_sys_time(void)
{
    return sys_time;
}

static inline void platform_display_off(void)
{
    DISPLAY_OFF;
}

static inline void platform_display_on(void)
{
    DISPLAY_ON;
}

static inline void platform_sprites_8x8(void)
{
    SPRITES_8x8;
}

static inline void platform_show_sprites(void)
{
    SHOW_SPRITES;
}

static inline void platform_hide_sprites(void)
{
    HIDE_SPRITES;
}

static inline void platform_show_background(void)
{
    SHOW_BKG;
}

static inline void platform_hide_background(void)
{
    HIDE_BKG;
}

static inline uint8_t platform_get_input(void)
{
    return joypad();
}

static inline void platform_wait_vbl(void)
{
    wait_vbl_done();
}

static inline void platform_vsync(void)
{
    vsync();
}

// === Sprite Operations ===

static inline void platform_set_sprite_tile(uint8_t nb, uint8_t tile)
{
    set_sprite_tile(nb, tile);
}

static inline void platform_set_sprite_data(uint8_t first, uint8_t nb, unsigned char *data)
{
    set_sprite_data(first, nb, data);
}

static inline void platform_move_sprite(uint8_t nb, uint8_t x, uint8_t y)
{
    move_sprite(nb, x, y);
}

// === Background & VRAM Operations ===

static inline void platform_set_bkg_data(uint8_t first, uint8_t nb, unsigned char *data)
{
    set_bkg_data(first, nb, data);
}

static inline void platform_set_bkg_tiles(uint8_t x, uint8_t y, uint8_t w, uint8_t h, unsigned char *tiles)
{
    set_bkg_tiles(x, y, w, h, tiles);
}

static inline void platform_set_vram_byte(uint8_t *addr, uint8_t byte)
{
    set_vram_byte(addr, byte);
}

static inline uint8_t* platform_get_bkg_xy_addr(uint8_t x, uint8_t y)
{
    return get_bkg_xy_addr(x, y);
}

// === Drawing & Console ===

static inline void platform_plot_point(uint8_t x, uint8_t y)
{
    plot_point(x, y);
}

static inline void platform_console_gotoxy(uint8_t x, uint8_t y)
{
    gotoxy(x, y);
}

#endif // PLATFORM_GB_H_
// platform/gb/platform_gb.h

#ifndef PLATFORM_GB_H_
#define PLATFORM_GB_H_

#include <stdint.h>


static inline void platform_display_off(void) {

}

static inline void platform_display_on(void) {
 
}

static inline void platform_sprites_8x8(void) {

}

static inline void platform_show_sprites(void) {

}

static inline void platform_hide_sprites(void) {

}

static inline void platform_show_background(void) {

}

static inline void platform_hide_background(void) {

}

static inline uint8_t platform_get_input(void) {

}

static inline void platform_wait_vbl(void) {

}

static inline void platform_vsync(void) {

}

// === Sprite Operations ===

static inline void platform_set_sprite_tile(uint8_t nb, uint8_t tile) {

}

static inline void platform_set_sprite_data(uint8_t first, uint8_t nb, unsigned char *data) {

}

static inline void platform_move_sprite(uint8_t nb, uint8_t x, uint8_t y) {

}

// === Background & VRAM Operations ===

static inline void platform_set_bkg_data(uint8_t first, uint8_t nb, unsigned char *data) {

}

static inline void platform_set_bkg_tiles(uint8_t x, uint8_t y, uint8_t w, uint8_t h, unsigned char *tiles) {

}

static inline void platform_set_vram_byte(uint8_t *addr, uint8_t byte) {

}

static inline uint8_t* platform_get_bkg_xy_addr(uint8_t x, uint8_t y) {

}

// === Drawing & Console ===

static inline void platform_plot_point(uint8_t x, uint8_t y) {

}

static inline void platform_console_gotoxy(uint8_t x, uint8_t y) {

}



#endif // SCENE_GAME_H_
// scenes/scene_game.c

#include <stdio.h>

#include "scene_game.h"

#include "../platform.h"

#include "../scene_manager.h" // scene manager for switching scenes
#include "../game_object.h" // GameObject manager
#include "../game_state.h"

// Game elements
#include "../graphics.h"
#include "../physics.h"
#include "../ball.h"
#include "../debug.h"
#include "../input.h"

// Map assets
#include "../tiles/pachinkoTiles.h"
#include "../backgrounds/game1Map.h"

void init_game_scene(void)
{
    platform_display_off();
    platform_sprites_8x8();

    // Load in the sprite and background we want
    set_sprite_sheet(PanchinkoTiles);

    set_game_background(game1Map, game1Tiles, 16);

    // Spawn some balls in
    for (uint8_t i = 0; i < NUM_BALLS; i++) {

        GameObject* ball;

        // Set initial position based on index
        if (i < 8) {
            uint8_t ball_x = 10 + i*8;
            uint8_t ball_y = 20;
            ball = spawn_ball(ball_x, ball_y);
        } else {
            uint8_t ball_x  = 10 + (i-8)*8;
            uint8_t ball_y = 30;
            ball = spawn_ball(ball_x, ball_y);
        }

        // Give random horizontal speed
        ball->physics.vx = RANDOM_HORIZONTAL_VX[i];
    }

    // Turn on our screen, sprites, and BG
    platform_show_background();
    platform_show_sprites();
    platform_display_on();
}

void update_game_scene(void)
{

    if (get_key_pressed_down(J_LEFT))
        launch_ball(find_lowest_ball(), 10, 80, LAUNCH_FORCE_X, -LAUNCH_FORCE_Y);

    if (get_key_pressed_down(J_RIGHT))
        launch_ball_random(find_lowest_ball(), 10, 80, LAUNCH_FORCE_X, -LAUNCH_FORCE_Y);

    if (get_key_pressed_down(J_UP))
        reset_all_balls();

    if (get_key_pressed_down(J_DOWN))
        set_scene(SCENE_GAME2);


    // Update all balls
    go_update_all_balls();
    
}

void cleanup_game_scene(void)
{
    platform_hide_sprites(); 
    platform_hide_background();
}

/* End of scenes/scene_game.c */
// scene_game.h

#ifndef SCENE_GAME_H_
#define SCENE_GAME_H_

void init_game_scene(void);

void update_game_scene(void);

void cleanup_game_scene(void);

#endif // SCENE_GAME_H_
// scenes/scene_game_screen.c

#include "../platform.h"
#include <stdio.h>

#include "scene_game2.h"

#include "../scene_manager.h" // scene manager for switching scenes
#include "../game_object.h" // GameObject manager
#include "../game_state.h"
// Game elements
#include "../graphics.h"
#include "../physics.h"
#include "../ball.h"
#include "../debug.h"
#include "../input.h"

// Map assets
#include "../tiles/pachinkoTiles.h"
#include "../backgrounds/game2Map.h"

// Font

#include "../tiles/menuFont.h"

void init_game2_scene(void)
{
    platform_display_off();
    platform_sprites_8x8();

    // Load in the sprite and background we want
    set_sprite_sheet(PanchinkoTiles);
    set_game_background(game2Map, PanchinkoTiles, 16);

    // Load basic font
    set_active_basic_font(menuFont, BASIC_FONT_TILESET_SIZE);
    print_text("a, b, c, d, e, f, g, h, i... 1,2,3,4,5-10...\n what is all this supposed to mean??? !!! --- ...",1 ,1);

    // Spawn some balls in
    for (uint8_t i = 0; i < NUM_BALLS; i++) {

        GameObject* ball;

        
        // Set initial position based on index
        if (i < 8) {
            uint8_t ball_x = 60 + i*8;
            uint8_t ball_y = 20;
            ball = spawn_ball(ball_x, ball_y);
        } else {
            uint8_t ball_x  = 10 + (i-8)*8;
            uint8_t ball_y = 30;
            ball = spawn_ball(ball_x, ball_y);
        }

        // Give random horizontal speed
        ball->physics.vx = RANDOM_HORIZONTAL_VX[i];
    }

    // Turn on our screen, sprites, and BG
    platform_show_background();
    platform_show_sprites();
    platform_display_on();
}

void update_game2_scene(void)
{

    if (get_key_pressed_down(J_LEFT))
        launch_ball(find_lowest_ball(), 10, 80, LAUNCH_FORCE_X, -LAUNCH_FORCE_Y);

    if (get_key_pressed_down(J_RIGHT))
        launch_ball_random(find_lowest_ball(), 10, 80, LAUNCH_FORCE_X, -LAUNCH_FORCE_Y);

    if (get_key_pressed_down(J_UP))
        reset_all_balls();

    if (get_key_pressed_down(J_DOWN))
        set_scene(SCENE_GAME);

    
    // Update all balls
    go_update_all_balls();
        
}

void cleanup_game2_scene(void)
{
    // Memset?
    platform_hide_sprites(); 
    platform_hide_background();
}

/* End of scenes/scene_game2.c */
// scene_game2.h

#ifndef SCENE_GAME2_H_
#define SCENE_GAME2_H_

void init_game2_scene(void);

void update_game2_scene(void);

void cleanup_game2_scene(void);

#endif // SCENE_GAME2_H_
// scenes/scene_game_screen.c

#include "scene_title_screen.h"
#include <stdio.h>

#include "../platform.h"

#include "../scene_manager.h" // scene manager for switching scenes
#include "../game_object.h" // GameObject manager
#include "../game_state.h"

// Game elements
#include "../graphics.h"
#include "../physics.h"
#include "../ball.h"
#include "../debug.h"
#include "../input.h"

// background
#include "../backgrounds/arod_gb.h"

// Font
#include "../tiles/menuFont.h"

// Menu options
#define START_GAME  1
#define CREDITS     2

// Stores menu selection (default start game)
uint8_t option_selected = START_GAME;


void init_title_scene(void)
{

    platform_display_off();
    platform_sprites_8x8();

    set_game_background(arod_gb_map, arod_gb_tiles, arod_gb_TILE_COUNT);

    set_active_basic_font(menuFont, BASIC_FONT_TILESET_SIZE);
    print_text("Aaron\nRodgers\nBall\nSimulator",1 ,3);
    print_text(">start game...",3 ,15);
    print_text(" credits",3 ,16);

    // Turn on our screen, sprites, and BG
    platform_show_background();
    platform_show_sprites();
    platform_display_on();
    
}

void update_title_scene(void)
{
    if (get_key_pressed_down(J_START) && option_selected == START_GAME)
        set_scene(SCENE_GAME);

    if (get_key_pressed_down(J_DOWN)){

        print_text(" start game...",3 ,15);
        // Add blinking cursor...
        //if (!(game.system.system_time & COLLISION_FRAME_SKIP))
            print_text(">credits",3 ,16);
        //else

        option_selected = CREDITS;
    }

    if (get_key_pressed_down(J_UP)){
        print_text(">start game...",3 ,15);
        print_text(" credits",3 ,16);
        option_selected = START_GAME;
    }


}

void cleanup_title_scene(void)
{
    platform_hide_sprites(); 
    platform_hide_background();
}

/* End of scenes/scene_game.c */
// scene_title_screen.h

#ifndef SCENE_TITLE_SCREEN_H_
#define SCENE_TITLE_SCREEN_H_

void init_title_scene(void);

void update_title_scene(void);

void cleanup_title_scene(void);

#endif // SCENE_TITLE_SCREEN_H_
/*

 MENUFONT.C

 Tile Source File.

 Info:
  Form                 : All tiles as one unit.
  Format               : Gameboy 4 color.
  Compression          : None.
  Counter              : None.
  Tile size            : 8 x 8
  Tiles                : 0 to 42

  Palette colors       : None.
  SGB Palette          : None.
  CGB Palette          : None.

  Convert to metatiles : No.

 This file was generated by GBTD v2.2

*/

/* Start of tile array. */
unsigned char menuFont[] =
{
  0x00,0x00,0x3C,0x3C,0x24,0x24,0x42,0x42,
  0x7E,0x7E,0x42,0x42,0x42,0x42,0x00,0x00,
  0x00,0x00,0x78,0x78,0x44,0x44,0x7C,0x7C,
  0x44,0x44,0x44,0x44,0x78,0x78,0x00,0x00,
  0x00,0x00,0x3C,0x3C,0x60,0x60,0x40,0x40,
  0x40,0x40,0x60,0x60,0x3C,0x3C,0x00,0x00,
  0x00,0x00,0x78,0x78,0x4C,0x4C,0x44,0x44,
  0x44,0x44,0x4C,0x4C,0x78,0x78,0x00,0x00,
  0x00,0x00,0x78,0x78,0x40,0x40,0x40,0x40,
  0x78,0x78,0x40,0x40,0x78,0x78,0x00,0x00,
  0x00,0x00,0x7C,0x7C,0x40,0x40,0x78,0x78,
  0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,
  0x00,0x00,0x38,0x38,0x40,0x40,0x40,0x40,
  0x4C,0x4C,0x44,0x44,0x7C,0x7C,0x00,0x00,
  0x00,0x00,0x44,0x44,0x44,0x44,0x44,0x44,
  0x7C,0x7C,0x44,0x44,0x44,0x44,0x00,0x00,
  0x00,0x00,0x7C,0x7C,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x7C,0x7C,0x00,0x00,
  0x00,0x00,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x44,0x44,0x78,0x78,0x00,0x00,
  0x00,0x00,0x44,0x44,0x48,0x48,0x50,0x50,
  0x70,0x70,0x58,0x58,0x4C,0x4C,0x00,0x00,
  0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x40,0x40,0x7C,0x7C,0x00,0x00,
  0x00,0x00,0x42,0x42,0x66,0x66,0x5A,0x5A,
  0x42,0x42,0x42,0x42,0x42,0x42,0x00,0x00,
  0x00,0x00,0x42,0x42,0x62,0x62,0x52,0x72,
  0x4A,0x4E,0x46,0x46,0x42,0x42,0x00,0x00,
  0x00,0x00,0x3C,0x3C,0x42,0x42,0x42,0x42,
  0x42,0x42,0x42,0x42,0x3C,0x3C,0x00,0x00,
  0x00,0x00,0x3C,0x3C,0x24,0x24,0x3C,0x3C,
  0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,
  0x00,0x00,0x38,0x38,0x44,0x44,0x44,0x44,
  0x44,0x44,0x4C,0x4C,0x7E,0x7E,0x00,0x00,
  0x00,0x00,0x78,0x78,0x44,0x44,0x58,0x58,
  0x60,0x60,0x50,0x50,0x4C,0x4C,0x00,0x00,
  0x00,0x00,0x7C,0x7C,0x44,0x44,0x70,0x70,
  0x0C,0x0C,0x44,0x44,0x7C,0x7C,0x00,0x00,
  0x00,0x00,0x7C,0x7C,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,
  0x00,0x00,0x44,0x44,0x44,0x44,0x44,0x44,
  0x44,0x44,0x44,0x44,0x7C,0x7C,0x00,0x00,
  0x00,0x00,0x44,0x44,0x44,0x44,0x28,0x28,
  0x28,0x28,0x28,0x28,0x10,0x10,0x00,0x00,
  0x00,0x00,0x00,0x00,0x42,0x42,0x42,0x42,
  0x5A,0x5A,0x66,0x66,0x42,0x42,0x00,0x00,
  0x00,0x00,0x42,0x42,0x24,0x24,0x18,0x18,
  0x18,0x18,0x24,0x24,0x42,0x42,0x00,0x00,
  0x00,0x00,0x44,0x44,0x28,0x28,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,
  0x00,0x00,0x3C,0x3C,0x04,0x04,0x08,0x08,
  0x10,0x10,0x20,0x20,0x3C,0x3C,0x00,0x00,
  0x00,0x00,0x38,0x38,0x4C,0x4C,0x54,0x54,
  0x64,0x64,0x44,0x44,0x38,0x38,0x00,0x00,
  0x00,0x00,0x10,0x10,0x30,0x30,0x10,0x10,
  0x10,0x10,0x10,0x10,0x7C,0x7C,0x00,0x00,
  0x00,0x00,0x18,0x18,0x24,0x24,0x04,0x04,
  0x18,0x18,0x20,0x20,0x3C,0x3C,0x00,0x00,
  0x00,0x00,0x38,0x38,0x04,0x04,0x04,0x04,
  0x18,0x18,0x04,0x04,0x3C,0x3C,0x00,0x00,
  0x00,0x00,0x20,0x20,0x20,0x20,0x28,0x28,
  0x28,0x28,0x3E,0x3E,0x08,0x08,0x00,0x00,
  0x00,0x00,0x7C,0x7C,0x40,0x40,0x78,0x78,
  0x04,0x04,0x04,0x04,0x78,0x78,0x00,0x00,
  0x00,0x00,0x38,0x38,0x40,0x40,0x40,0x40,
  0x7C,0x7C,0x44,0x44,0x7C,0x7C,0x00,0x00,
  0x00,0x00,0x7E,0x7E,0x42,0x42,0x02,0x02,
  0x04,0x04,0x08,0x08,0x10,0x10,0x00,0x00,
  0x00,0x00,0x3C,0x3C,0x24,0x24,0x24,0x24,
  0x3C,0x3C,0x24,0x24,0x3C,0x3C,0x00,0x00,
  0x00,0x00,0x7C,0x7C,0x44,0x44,0x7C,0x7C,
  0x04,0x04,0x04,0x04,0x7C,0x7C,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x3C,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x40,0x40,0xC0,0xC0,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0xC0,0xC0,0xC0,0xC0,0x00,0x00,
  0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x00,0x00,0x10,0x10,0x00,0x00,
  0x00,0x00,0x38,0x38,0x04,0x04,0x1C,0x1C,
  0x10,0x10,0x00,0x00,0x10,0x10,0x00,0x00,
  0x00,0x00,0x38,0x38,0x3C,0x3C,0x3E,0x3E,
  0x3E,0x3E,0x3C,0x3C,0x38,0x38,0x00,0x00
};

/* End of MENUFONT.C */

/*

 MENUFONT.H

 Include File.

 Info:
  Form                 : All tiles as one unit.
  Format               : Gameboy 4 color.
  Compression          : None.
  Counter              : None.
  Tile size            : 8 x 8
  Tiles                : 0 to 42

  Palette colors       : None.
  SGB Palette          : None.
  CGB Palette          : None.

  Convert to metatiles : No.

 This file was generated by GBTD v2.2

*/


/* Bank of tiles. */
#define menuFontBank 0
/* Start of tile array. */
extern unsigned char menuFont[];

/* End of MENUFONT.H */

/*

 PINBALLTILES.C

 Tile Source File.

 Info:
  Form                 : All tiles as one unit.
  Format               : Gameboy 4 color.
  Compression          : None.
  Counter              : None.
  Tile size            : 8 x 8
  Tiles                : 0 to 15

  Palette colors       : None.
  SGB Palette          : None.
  CGB Palette          : None.

  Convert to metatiles : No.

 This file was generated by GBTD v2.2

*/

/* Start of tile array. */
unsigned char PanchinkoTiles[] =
{
  0x00,0x00,0x3C,0x3C,0x76,0x78,0x7A,0x7E,
  0x7E,0x7E,0x7E,0x7E,0x3C,0x3C,0x00,0x00,
  0xFF,0xFF,0x00,0xFF,0x00,0xFF,0xFF,0x00,
  0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x10,
  0x00,0x3C,0x10,0x18,0x00,0x00,0x00,0x00,
  0x00,0x01,0x00,0x03,0x00,0x07,0x00,0x0F,
  0x00,0x1F,0x00,0x3F,0x00,0x7F,0x00,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0x01,0xFF,0x03,0xFF,0x07,0xFF,0x0F,0xFF,
  0x1F,0xFF,0x3F,0xFF,0x7F,0xFF,0xFF,0xFF,
  0x00,0x80,0x00,0xC0,0x00,0xE0,0x00,0xF0,
  0x00,0xF8,0x00,0xFC,0x00,0xFE,0x00,0xFF,
  0x80,0xFF,0xC0,0xFF,0xE0,0xFF,0xF0,0xFF,
  0xF8,0xFF,0xFC,0xFF,0xFE,0xFF,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

/* End of /tiles/pachinkoTiles.C */
/*

 PINBALLTILES.H

 Include File.

 Info:
  Form                 : All tiles as one unit.
  Format               : Gameboy 4 color.
  Compression          : None.
  Counter              : None.
  Tile size            : 8 x 8
  Tiles                : 0 to 15

  Palette colors       : None.
  SGB Palette          : None.
  CGB Palette          : None.

  Convert to metatiles : No.

 This file was generated by GBTD v2.2

*/


/* Bank of tiles. */
#define PinballTilesBank 0
/* Start of tile array. */
extern unsigned char PanchinkoTiles[];

/* End of PINBALLTILES.H */
